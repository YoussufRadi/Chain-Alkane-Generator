# Chain-Alkane-Generator
<br><h3>
Project Description
</h4>
<p>
Hydrocarbons are compounds composed of carbon and hydrogen. An alkane is a saturated hydrocar-
bon. Each carbon atom is bound to the maximum number possible: Four atoms. Alkanes can have their atoms arranged in what is called a normal, straight-chain or unbranched way.
</p>
<p>
Alkanes with at least four carbon atoms exhibit structural isomerism. This is because they can exist not only as straight-chain molecules, but also in a branched-chain structure. For instance, the alkane with four carbon atoms has two isomers and the alkane with five carbon atoms has three isomers.
</p>

<p>
longest chain of three carbon atoms and a branch of CH3. While generating the different isomers of some formula, finding the distinct ones can be a bit tricky. Some structures appear to be additional isomers when, in fact, they are identical to already generated ones once rotated and/or mirrored. This project is a system for alkane isomers generation according to some specific rules.
</p>
<h3>
Prolog Project Report
</h3>
<h4>
Predicts and a brief description:
</h4>
<div><p style="color:red">straight_chain_alkane(N,A)</font></br>
o is responsible for generating a straight chain alkane, it checks if N = 1 it
returns carb(h,h,h,h) else it generates the longest possible chain by calling
</br>its helper straight_chain_helper(N,A,T)
</div>
<div><p style="color:red">straight_chain_helper(N,A,T)</font></br>
o this is a recursive call where A acts as an accumulator to follow up the list
,after each addition of an atom and when N = 1 the call will append the
last atom carb(h,h,h,c) and return the chain as list T.
</br>o handles the condition ("No branch should be attached to either carbon
atom at the end of the chain") as it adds the last element always as
carb(_,h,h,h).
</div>
<div><p style="color:red">branch_name(S,N)</font></br>
o explained in the notes
</div>
<div><p style="color:red">add_branch_to_carbon(InC, BSize, ResC)</font></br>
o explained in the notes
</br>o handles the condition ("a carbon atom is allowed to have a down branch
attached") by checking that either top is h so it modifies the top or the top
is not h so it modifies the bottom.
</div>
<div><p style="color:red">generate(S,E,X)</font></br>
o generates numbers starting from S to E and returns every integer between
them in X.
</div>
<div><p style="color:red">break_down(N,L)</font></br>
o used to find every different possibility that can number N be broke to in a
form of list L, it calls its helper break_down(N,X,L).ï‚· break_down(N,X,L)
</br>o helper of break_down(N,L) where X is used to keep track of the last
number added as head to the previous list, to avoid having duplicates and
to get a sorted list
</br>o handles the condition ("If a carbon atom has two branches attached to it,
then the number of carbon atoms in the top branch has to be less than or
equal to the number of atoms in the down branch" ) as the list is always
sorted, therefore smaller values are always added upwards
</div>
<div><p style="color:red">edit_list(Pos,Val,List,R)</font></br>
o receives a single element value from the list generated by break down as
Val, and edits the element in Pos in the List by calling
add_branch_to_carbon(List[Pos], Val, Result)
</br>o it handles the condition ("The number of carbon atoms in any branch
should not lead to any new chains that are longer than the current longest
chain") by checking the left and right of every atom before editing it,
making sure that the new branch will not be greater than the longest
branch.
</div>
<div><p style="color:red">permutate(Val,List,R)</font></br>
o generates different permutations of edit_list(Pos,Val,List,R) by calling
generate for different values of Pos starting from 1 till List length.
</div>
<div><p style="color:red">permutate_list(K,List,R)</font></br>
</br>o generates different values of permutate(Val,List,R) by traversing a list K
and calling Val for each value of K.
</div>
<div><p style="color:red">permutate_list_remove(A,L,X)</font></br>
o calls permutate_list(K,List,R) and removes the duplicates.
</div>
<div><p style="color:red">length_chain(N,X,Y)</font></br>
o receives N and return the value of the next longest chain X and the
number Y to be used in break_down, calls generate K to get a number
from 1 to N and calls its helper length_chain(N,K,X,Y).
</div>
<div><p style="color:red">length_chain(N,K,X,Y)</font></br>
o get K and returns X as N-K and Y as K if X>2.
</br>o handles case that lowest branched alkane is having 3 carbons in the center
chain.
</div>
<div><p style="color:red">branched_alkane(N,BA)</font></br>
o uses length_chain(N,X,Y) and calls its helper branched_alkane(X,Y,BA)
returning the branched alkane
</div>
<div><p style="color:red">branched_alkane(X,Y,BA)</font></br>
o takes X as the length of the center chain and Y to be break_down the calls
permutate_list_remove to get all possible permutation returned as BA
</div>
<div><p style="color:red">isomers(N,[A2|A])</font></br>
o makes a set of all possible results for branched alkane with value N then
calls remove duplicates , more over it adds the straight chain in the
begging of the list.
</div>
<div><p style="color:red">duplicate_remove([H|T],Result)</font></br>
o takes a list [H|T] and checks if the reverse of H is repeated in the rest of
the list it removes H else it keeps H and checks the rest of the list T.
</div>
<div><p style="color:red">reverse_middle(List,R)</font></br>
o skips the first element and last element in a List and reverses all other
elements inside this list and returns the result as R
</div>
